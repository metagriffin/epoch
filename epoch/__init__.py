# -*- coding: utf-8 -*-
#------------------------------------------------------------------------------
# file: $Id$
# auth: metagriffin <mg.github@metagriffin.net>
# date: 2016/09/19
# copy: (C) Copyright 2016-EOT metagriffin -- see LICENSE.txt
#------------------------------------------------------------------------------
# This software is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This software is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.
#------------------------------------------------------------------------------

import time
from datetime import datetime, timedelta, tzinfo
import calendar
import re

import pytz

#------------------------------------------------------------------------------

DEFAULT_TZ              = pytz.UTC

#------------------------------------------------------------------------------
def setDefaultTz(tz):
  global DEFAULT_TZ
  DEFAULT_TZ = getTz(tz)

#------------------------------------------------------------------------------
def getDefaultTz():
  return getTz()

#------------------------------------------------------------------------------
def getTz(tz=None):
  '''
  Returns the `datetime.tzinfo` object for timezone `tz`. If `tz` is
  None or not specified, returns the package-default timezone, which
  defaults to UTC.
  '''
  # todo: should `tz` default to the machines default locale? this is
  #       good for client-side programs, but not for server-side
  #       applications...
  tz = tz or DEFAULT_TZ
  if isinstance(tz, tzinfo):
    return tz
  return pytz.timezone(tz)

#------------------------------------------------------------------------------
def now():
  return time.time()

#------------------------------------------------------------------------------
def zulu(ts=None, ms=True):
  '''
  Returns the specified epoch time `ts` (or current time if None or
  not provided) as an ISO 8601 Combined string in zulu time (with
  millisecond precision), e.g. ``epoch.zulu(1362187446.553)`` =>
  ``'2013-03-02T01:24:06.553Z'``. If `ms` is True (the default),
  milliseconds will be included, otherwise truncated. If `ts` has
  beyond-millisecond precision, it will be truncated to
  millisecond-level precision.
  '''
  if ts is None:
    ts = now()
  ms = '.%03dZ' % (round(ts * 1000) % 1000,) if ms else 'Z'
  return time.strftime('%Y-%m-%dT%H:%M:%S', time.gmtime(ts)) + ms
z = zulu

#------------------------------------------------------------------------------
_zulu_cre = re.compile(r'^(\d{4})-?(\d{2})-?(\d{2})T(\d{2}):?(\d{2}):?(\d{2})(\.\d{1,3})?Z$')
def parseZulu(text):
  '''
  Parses an ISO 8601 Combined string into an epoch timestamp. Note
  that this function is intended to be used with strings generated by
  `epoch.zulu`, and is therefore not very forgiving. For a much more
  human-friendly parser, try::

    import dateutil.parser
    result = dateutil.parser.parse(text, tzinfos = {'UTC': 0}))

  but please note that it does not properly warn about ambiguities;
  for example ``01/02/03`` gets interpreted without hesitation as
  ``2003/01/02``... ugh.
  '''
  res = _zulu_cre.match(text)
  if not res:
    raise SyntaxError(
      '%r is not a valid ISO 8601 Combined date/time string' % (text,))
  res = res.groups()
  res = res[:6] + ('{:0<3}'.format((res[6] or '.0')[1:]),)
  return dt2ts(pytz.UTC.localize(datetime(*[int(x) for x in res])))

#------------------------------------------------------------------------------
def dt2ts(dt):
  '''
  Returns a UNIX epoch timestamp for the specified `tz` `datetime.datetime`
  object.
  '''
  return float(calendar.timegm(dt.utctimetuple()))

#------------------------------------------------------------------------------
def ts2dt(ts, tz=None):
  '''
  Returns a timezone-aware `datetime.datetime` object for the
  specified UNIX epoch timestamp `ts` object. The `tz` object can be
  anything accepted by :func:`getTz`.
  '''
  return datetime.fromtimestamp(ts, getTz(tz))

#------------------------------------------------------------------------------
def dtreplace(dt, *args, **kw):
  '''
  A version of :meth:`datetime.datetime.replace()` that properly
  maintains the `dt.tzinfo` if the replace will cause DST boundary
  switching.
  '''
  if 'tzinfo' in kw:
    raise TypeError('dtreplace cannot be used to replace `tzinfo`')
  return dt.tzinfo.localize(dt.replace(tzinfo=None).replace(*args, **kw))

#------------------------------------------------------------------------------
def tzcorrect(dt):
  '''
  Forces a "re-timezoning" of the `dt` object. This is necessary when
  working with `datetime.datetime` objects because they behave
  incorrectly when they are forced to cross DST boundaries during
  calls to `datetime.datetime.replace(...)` or adjustments via
  `datetime.timedelta` objects.
  '''
  if not dt.tzinfo:
    raise TypeError('tzcorrect cannot be used with naive datetimes')
  return dt.tzinfo.localize(dt.replace(tzinfo=None))

#------------------------------------------------------------------------------
def sod(ts=None, tz=None, offset=None):
  '''
  Returns the epoch timestamp of the start of the current day relative
  to the timezone `tz`. If `ts` is specified, the start of the day
  containing `ts` is returned. If `offset` is specified, it is taken
  to be an integral number of days to offset the returned value by.
  Note that due to leap seconds, daylight savings, etc, this is more
  complex than just 60 seconds * 60 minutes * 24 hours.
  '''
  tz = getTz(tz)
  if ts is None:
    ts = now()
  offset = int(offset or 0)
  ret = dtreplace(ts2dt(ts, tz=tz), hour=0, minute=0, second=0, microsecond=0)
  if offset:
    ret = tzcorrect(ret + timedelta(days=offset))
  return dt2ts(ret)

#------------------------------------------------------------------------------
def sow(ts=None, tz=None, offset=None, day=None):
  '''
  Returns the epoch timestamp of the start of the current Gregorian
  week relative to the timezone `tz`. If `ts` is specified, the start
  of the week containing `ts` is returned. If `offset` is specified,
  it is taken to be an integral number of weeks to offset the returned
  value by. Note that due to leap days, leap seconds, daylight
  savings, etc, this is more complex than just 60 seconds * 60 minutes
  * 24 hours * 7 days. If `day` is specified, it specifies which day
  is defined to be the "first" day of the week, where ``0`` (the
  default) is Monday through ``6`` being Sunday.
  '''
  tz = getTz(tz)
  if ts is None:
    ts = now()
  offset = int(offset or 0)
  ret = dtreplace(ts2dt(ts, tz=tz), hour=0, minute=0, second=0, microsecond=0)
  day = min(max(int(day or 0), 0), 6)
  if day <= ret.weekday():
    doff = day - ret.weekday()
  else:
    doff = day - ret.weekday() - 7
  if doff:
    ret += timedelta(days=doff)
  if offset:
    ret += timedelta(weeks=offset)
  if doff or offset:
    # NOTE: this call to `dtreplace` causes a dt.tzinfo correction
    #       because `datetime.datetime` behaves incorrectly when it is
    #       forced to cross DST boundaries...
    ret = tzcorrect(ret)
  return dt2ts(ret)

#------------------------------------------------------------------------------
def som(ts=None, tz=None, offset=None):
  '''
  Returns the epoch timestamp of the start of the current Gregorian
  month relative to the timezone `tz`. If `ts` is specified, the start
  of the month containing `ts` is returned. If `offset` is specified,
  it is taken to be an integral number of months to offset the returned
  value by.
  '''
  tz = getTz(tz)
  if ts is None:
    ts = now()
  offset = int(offset or 0)
  ret = dtreplace(ts2dt(ts, tz=tz), day=1, hour=0, minute=0, second=0, microsecond=0)
  if offset:
    # todo: all of this is because timedelta() does not support
    #       ``months=X``... is there perhaps another alternative?
    sign = 1 if offset > 0 else -1
    offset = abs(offset)
    if offset >= 12:
      ret = dtreplace(ret, year=ret.year + sign * ( offset // 12 ))
      offset %= 12
    if offset:
      year = ret.year
      month = ret.month + ( offset * sign )
      if month < 1:
        year -= 1
        month += 12
      elif month > 12:
        year += 1
        month -= 12
      ret = dtreplace(ret, year=year, month=month)
  return dt2ts(ret)

#------------------------------------------------------------------------------
def soy(ts=None, tz=None, offset=None):
  '''
  Returns the epoch timestamp of the start of the current Gregorian
  year relative to the timezone `tz`. If `ts` is specified, the start
  of the year containing `ts` is returned. If `offset` is specified,
  it is taken to be an integral number of years to offset the returned
  value by.
  '''
  tz = getTz(tz)
  if ts is None:
    ts = now()
  offset = int(offset or 0)
  ret = dtreplace(ts2dt(ts, tz=tz), month=1, day=1, hour=0, minute=0, second=0, microsecond=0)
  if offset:
    ret = dtreplace(ret, year=ret.year + offset)
  return dt2ts(ret)

#------------------------------------------------------------------------------
# end of $Id$
# $ChangeLog$
#------------------------------------------------------------------------------
